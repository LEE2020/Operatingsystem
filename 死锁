死锁
* 死锁的基本概念
* 资源分配图
* 死锁预防
* 死锁避免
* 死锁检测与解除
* 哲学家就餐问题


死锁的基本概念
  一组进程中，每个进程都无限等待被该组进程中的另一进程所占有的资源，因而永远无法得到的资源，
这种现象称为进程死锁，这一组进程就被称为死锁进程。
如果死锁发生，会浪费大量系统资源，甚至导致系统奔溃。（因为1. 参与死锁的所有进程都在等待资源，
2. 参与死锁的进程是当前系统中所有进程的子集，当更多的进行进入死锁，子集会扩大至系统崩溃）

死锁出现的原因
1. 资源数量有限，锁和信号量错误使用
  a. 资源的使用方式：“申请-分配-使用-释放” 模式
  b. 可重用资源：可被多个进程多次使用（可抢占资资源/不可抢占资源：处理器，I/O 部件，内存，
文件，数据库，信号量）
  c. 可消耗资源：只可使用一次，可创建和销毁的资源（信号，中断，消息）
死锁主要探讨在可重用资源上的状况（进程竞争可重用资源）

活锁和饥饿
活锁：先加锁/再轮询 -> 既无进展也无阻塞
饥饿：资源分配策略决定

产生死锁的必要条件：
1. 互斥使用（资源独占）：一个资源每次只能给一个进程使用
2. 占有且等待（请求和保持，部分分配）：进程在申请新的资源的同时保持对原有资源的占有
3. 不可抢占（不可剥夺）： 资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者资源释放
4. 循环等待：存在一个进程等待队列{p1,p2,...,pn}, 其中p1等待p2占有的资源，p2等待p3占有的资源....
pn等待p1占有的资源,形成一个进程的等待环路

资源分配图（RAG: resource allocation graph)
用有向图描述系统资源和进程的状态，二元组 G=(V,E)
V: 结点的集合，分为P（进程），R（资源）两部分
   P1={P1,P2,...,Pn} ; R={R1,R2,...,Rm}
E: 有向边的集合，其元素为有序二元组
  (Pi，Rj)或（Rj,Pi)

画法说明：系统由若干类资源构成，一类资源称为一个资源类；每个资源类包含若干个同种资源，称为资源实例。
资源类： 方框表示；资源实例：用方框中的黑圆点表示；进程：用圆圈中加进程名表示
分配边： 资源实->进程 申请边：进程->资源类









死锁的检测与解除

死锁的检测：
  1. 允许死锁发生，但是操作系统会不断监视系统进展情况，判断死锁是否真的发生
  2. 一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行
检测时机：
  1. 当进程犹豫资源请求不满足而等待检测死锁（缺点：系统开销大）
  2. 定时检测
  3. 系统资源利用率下降时检测死锁

  一个简单的死锁检测算法
  * 每个进程，每个资源指定唯一编号
  * 设置一张资源分配表，记录各个进程与其占用资源之间的关系
  * 设置一张进程等待表，记录各个进程与要申请资源之间的关系
如果等待序列出现环路，则会发生死锁现象
例如：
资源分配表（r1,p1),(r2,p5),(r3,p4),(r4,p1)...
进程等待表（p1,r1),(p2,r3),(p4,r4),...
则等待序列 p1->r1->p2->r3->p4->r4->p1 (出现环路，死锁发生）

死锁的解除：
重要的是以最小的代价恢复系统的运行，方法如下几种：
1. 撤销所有死锁进程
2. 进程回退（roll back)再启动
3. 按照某种原则逐一撤销死锁进程，知道...
4. 按照某种原则逐一抢占资源（资源被抢占的进程必须回退到之前的对应状态）,直到...
  
  
