银行家算法（Dijkstra提出的算法）

  仿造银行家发放贷款时采取的控制方式而设计的一种死锁避免的方式。
算法的应用条件

  1. 固定数量的进程中共享数量固定的资源
  2. 每个进程预先指定完成工作所需的最大资源数量
  3. 进程不能申请比系统中可用资源总数还多的资源
  4. 进程等待资源的时间是有限的
  5. 如果系统满足了进程对资源的最大需求，那么进程应该在有限的时间内使用资源，然后归还给系统

例如：n: 系统中进程的数量 m:资源类数量，定义数据结构
Available : ARRAY[1...m] 每类资源的可用量
Max: ARRAY[1...n,1...m] 每个进程所需要每类的资源量
Allocation: ARRAY[1...n,1...m] 每个进程分配每类的资源量
Need: ARRAY[1...n,1...m] 每个进程还需要分配每类的资源量
Request: ARRAY[1...n,1...m] 本次请求进程申请的资源量
当进程Pi提出资源申请时，系统会执行以下步骤：
1. 若Request[i] <= Need[i], 转2；否则报错返回
2. 若Request[i] <= Available, 转3；否则进程等待
3. 假设系统分配了资源，系统则有新的状态
  Available = Available - Request[i]
  Allocation[i] = Allocation[i] + Request[i]
  Need[i] = Need[i] - Request[i];
若系统的新状态是安全的，则分配完成
若系统的新状态是不安全的，则恢复原来状态，进程进入等待状态

如果判断系统处于安全状态？安全性检查的方法来完成系统安全状态的检查，定义数据结构
Work: ARRAY[1...m] 当前系统可用的资源量
Finish: ARRAY[1...n] 进程标识

安全性检查步骤：
1. Work = Available
   Finish = False
2. 寻找满足条件的i 进程：
    a. Finish[i]== False;
    b. Need[i] <= Work; 
    如果存在，则转4
3. Work = Work + Allocation;
   Finish[i] = true'
   转2
4. 若对所有的i, Finish[i] == true;则系统处于安全状态，否则系统处于不安全状态。 
例如：
P1,P2,P3 3个进程，其中目前资源占有量，资源最大需求量，资源尚需求量上分别是P1(1,4,3),P2(4,6,2),P3(5,8,3),
目前系统剩余资源量是2，系统是否处于安全状态？
剩余资源满足P2需求，P2,P3,P1//P2,P1,P3则为安全序列，只要系统中存在一组安全序列，则系统处于安全状态。




